{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE StrictData #-} -- avoid lazy fields in records
{-# LANGUAGE RecordWildCards #-}

{- Type families work similary to type aliases. Any time we use
   `ShellOutput ListDirectory` it's essentially a synonym for `[FilePath]`.

   Like with type aliases, this can have the down side that it may allow us to
   accidentally write code that depends on what should have been an
   implementation detail.

   One way to avoid this problem is to use "associated data families".
-}
module GHCExt.Kinds.AssociatedTypeFamily.ShellCmd where
import Data.Kind -- <== needed by associated type family to reference "Type"
import System.Process (readProcess)

{- See how it changes from using FunctionalDependencies
   |
   | class ShellCmd cmd cmdOutput | cmd -> cmdOutput where
   |
   v
-}
class ShellCmd cmd where
  {- ShellOutput is an associated type family, that we use to map a particular
     instance of ShellCmd to the type of output that will be generated by
     running the command.
  -}
  type ShellOutput cmd :: Type

  runCmd ::
    Monad m =>
    cmd ->
    (String -> [String] -> m String) ->
    m (ShellOutput cmd)

newtype ListDirectory =
  ListDirectory { listDirectoryName :: FilePath }

instance ShellCmd ListDirectory where
  {- This tells the compiler that the ShellOutput type family, when called with
     the type ListDirectory, returns a type of the value [FilePath]
  -}
  type ShellOutput ListDirectory = [FilePath]

  runCmd (ListDirectory dir) run =
    lines <$> run "ls" ["-1", dir] -- "-1" option list only file names

data Grep =
  Grep { grepMatch :: String, grepFiles :: [String] }

data GrepMatch = GrepMatch
  { grepMatchingFileName :: FilePath
  , grepMatchingLineNumber :: Int
  , grepMatchingLineContents :: String
  } deriving (Eq, Show)

-- Grep response format: "filename:linenumber:linecontent"
parseGrepResponse :: [String] -> [GrepMatch]
parseGrepResponse = map parseLine
  where
    parseLine responseLine =
      let
        {- span :: (a -> Bool) -> [a] -> ([a], [a])

           span, applied to a predicate p and a list xs, returns a tuple where
           first element is the longest prefix (possibly empty) of xs of
           elements that satisfy p and second element is the remainder of the list:
        -}
        (fileName, rest) = span (/= ':') responseLine
        (matchNumber, rest') = span (/= ':') $ tail rest
        contents = tail rest' -- using tail we remove ':' from the head
      in GrepMatch fileName (read matchNumber) contents

instance ShellCmd Grep where
  {- This tells the compiler that the ShellOutput type family, when called with
     the type Grep, returns a type of the value [GrepMatch]
  -}
  type ShellOutput Grep = [GrepMatch]

  runCmd Grep{..} run =
    parseGrepResponse . fixResponses . lines <$> run "grep" grepArgs
    where
      grepArgs = "-n" : grepMatch : grepFiles
      {- grep command returns different output depending on number of files passed:

         grep -n pattern file1
         linenumber:linecontent

         grep -n pattern file1 file2
         filename:linenumber:linecontent
       -}
      fixResponses :: [String] -> [String]
      fixResponses responseLines =
        case grepFiles of
          [fname] -> (\l -> fname <> ":" <> l) <$> responseLines
          _multipleFiles -> responseLines

{- Definition of data type Pipe needs only two type parameters now
   |
   | data Pipe a r b r' = Pipe a (r -> b)
   |
   v
-}
data Pipe a b = Pipe a (ShellOutput a -> b)
{- We might have known  that `r` was supposed to be the output type of `a` and
   that `r'` was supposed to be the output type of `b`, but there was nothing
   that required that to be the case.

   Using type families, we can be more explicit that the output type of the
   command `a` must be used to generate the command `b`
-}

instance (ShellCmd a, ShellCmd b) =>
  ShellCmd (Pipe a b) where
  type ShellOutput (Pipe a b) = ShellOutput b

  runCmd (Pipe a mkB) run = do
    result <- runCmd a run
    runCmd (mkB result) run

grepFilesInDirectory ::
  String ->
  FilePath ->
  Pipe ListDirectory Grep
grepFilesInDirectory match dir =
  Pipe (ListDirectory dir) $
    Grep match . map (\fname -> dir <> "/" <> fname)

runShellCommand :: ShellCmd cmd => cmd -> IO (ShellOutput cmd)
runShellCommand cmd =
  runCmd cmd (\cmdName args -> readProcess cmdName args "")
